#!/usr/bin/python -u    
# -*- coding: utf-8 -*-
# The -u makes output unbuffered, so it will show up immediately
import json
import sys
import socket
import select
import struct
import time
# forwarding table is a dictionary of <IP: Port> 
'''
Forwarding Table is a dictionary of <IP, Port>
FUNCTIONALITY:
1) add entries
2) delete entries
3) flush the tale of any bridges port changes state (designated, root...)
4) timeout forwarding table entries 5 sec after receiving the last msg
   from that address
5) print 'forwarding', 'broadcasting' or 'not forwarding' when the bridge made 
   a decision
'''

'''
Bridge:
FUNCTIONALITY:
1) for a spanning tree
2) handle failures
3) intruduce new bridges
4) learn location of end host
5) deliver and host packets to the destination
6) handle mobility between end-hosts getween LANs
7) bridge broadcast BPDU on all ports and dont broadcast more freq 
   than once/500s 
8) constantly listen to new roots and should know about
   which ports are active and inactive upon receiving each BPDU
'''
class Bridge(object):

    def __init__(self, b_id, lans):
        self.b_id = b_id
        self.lans = lans
        self.notactiveports = []
        self.start = 0 
        self.stop = 0
        self.forwarding_table = {}                              # {"<destination>": "<port>"}
        self.bpdus = {}                                         #{<port_number>: [{"root": "2", "cost": 1, "timestamp": FFF}]
        self.root = b_id

    def addToBPDUTable(self, port, root, cost):
        self.bpdus[port] = {"root": root, "cost": cost, "timestamp": time.time()}

    def sendBPDU(self, s, port, cost):
        self.root = self.b_id
        message = {"source":self.b_id, "dest":"ffff", "type": "bpdu", "message":{"id":"92b4", "root":self.root, "cost":cost, "port":port}}
        s.send(json.dumps(message))
        #self.addToBPDUTable(port)
        print "BPDU message sent: %s" % json.dumps(message)

    def createSTP(self, port, newBPDU, s):
        new_root = newBPDU["message"]["root"]
        new_cost = newBPDU["message"]["cost"]
        new_b_id = newBPDU["source"]
        self.addToBPDUTable(port, newBPDU["message"]["root"], newBPDU["message"]["cost"])

        if (int(self.root, 16) < int(new_root, 16)):
            print "This Bridge root is less than new one"
        elif ( (int(self.root, 16) == int(new_root, 16) )  and ( currentBPDU["cost"] < new_cost]) ):
            print "This Bridge cost is less than new one"
        elif ( (int(self.root, 16) == int(new_root, 16) )  and ( currentBPDU["cost"] == new_cost) and (int(seld.b_id, 16) < int(new_b_id, 16)) ):
            print "This Bridge id is less than new one"
        else:
            self.root = new_root
            self.sendBPDU(s, port, new_cost + 1)

    def sendDataOnThisPort(self):
        print "sendDataOnThisPort"

    def processData(self, port, data, s):
        destination = data["dest"]
        if destination in self.forwarding_table:
            s.sendDataOnThisPort()           # WHAT?
        else:
            s.broadcastData()                 # WHAT?
            self.forwarding_table[destination] = port




    def start(self):
        sockets = []    

        # creates sockets and connects to them
        for x in range(len(self.lans)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(pad(self.lans[x]))
            sockets.append(s)
        print "Bridge " + self.b_id + " starting up\n"

        last_sent = time.time()

        while True:

            ready, ignore, ignore2 = select.select(sockets, [], [], 1)

            port = 1;
            # Reads from each fo the ready sockets
            for x in ready:

                self.sendBPDU(x, port, 0)

                if ((time.time() - last_seen) >= 0.5):
                    self.sendBPDU(x, port)
                    last_sent = time.time()

                #checkForTimedoutBPDUs

                data = x.recv(1500)
                print "Data received: %s" % data
                data_json = json.loads(data)

                if (data_json['type'] == 'bpdu'):
                    self.createSTP(port, data_json, x) #which port?

                elif (data_json['type'] == 'data'):
                    self.processData(port, data_json, s)

                else:
                    print "ERROR: unknown data type"

                port = port + 1


# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

if __name__ == "__main__":
    bridge = Bridge(sys.argv[1], sys.argv[2:])

    bridge.start()


