#!/usr/bin/python -u    
# -*- coding: utf-8 -*-
# The -u makes output unbuffered, so it will show up immediately
import json
import sys
import socket
import select
import struct
import time
# forwarding table is a dictionary of <IP: Port> 
'''
Forwarding Table is a dictionary of <IP, Port>
FUNCTIONALITY:
1) add entries
2) delete entries
3) flush the tale of any bridges port changes state (designated, root...)
4) timeout forwarding table entries 5 sec after receiving the last msg
   from that address
5) print 'forwarding', 'broadcasting' or 'not forwarding' when the bridge made 
   a decision
'''

'''
Bridge:
FUNCTIONALITY:
1) for a spanning tree
2) handle failures
3) intruduce new bridges
4) learn location of end host
5) deliver and host packets to the destination
6) handle mobility between end-hosts getween LANs
7) bridge broadcast BPDU on all ports and dont broadcast more freq 
   than once/500s 
8) constantly listen to new roots and should know about
   which ports are active and inactive upon receiving each BPDU
'''
class Bridge(object):

    def __init__(self, b_id, lans):
        self.b_id = b_id
        self.lans = lans
        self.notactiveports = []
        self.start = 0 
        self.stop = 0
        self.forwarding_table = {}
        self.bpdus = {}
        self.root = -1

    def sendBPDU(self, s, port):
        self.root = self.b_id
        message = {"source":self.b_id, "dest":"ffff", "type": "bpdu", "message":{"id":"92b4", "root":self.root, "cost":0, "port":port}}
        s.send(json.dumps(message))
        print "BPDU message sent: %s" % json.dumps(message)



    def start(self):
        sockets = []    

        # creates sockets and connects to them
        for x in range(len(self.lans)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(pad(self.lans[x]))
            sockets.append(s)
        print "Bridge " + self.b_id + " starting up\n"

        last_sent = time.time()

        while True:

            ready, ignore, ignore2 = select.select(sockets, [], [], 1)

            port = 1;
            # Reads from each fo the ready sockets
            for x in ready:

                self.sendBPDU(x, port)

                if ((time.time() - last_seen) >= 0.5):
                    self.sendBPDU(x, port)
                    last_sent = time.time()

                data = x.recv(1500)
                print "Data received: %s" % data
                data_json = json.loads(data)

                if (data_json['type'] == 'bpdu'):
                    self.createSTP(data_json)

                elif (data_json['type'] == 'data'):
                    self.processData(data_json)

                else:
                    print "ERROR: unknown data type"

                port = port + 1

                #checkForTimedoutBPDUs

                #send BPDU every 500 ms + update BPDU table {"port": {"src": "", "last_seen": ""}}


            # data = x.recv(1500)
            # print(data)

            #     if data is bpdu data: do checks, update bpdu_table
            #     if data is data: broadcast or forward, update forwarding_table



            



    # def print_ft(self):
    #     res = ''
    #     for addr, p in self.forwarding_table.iteritems():
    #         res += '->> id: ' + addr + ' port: ' + p
    #     print res

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

# def add_bpdu(bridge, msg, port):
#     src = msg['source']
#     if bridge.forwarding_table.get(src) == None:
#         bridge.forwarding_table[src] = port

if __name__ == "__main__":
    bridge = Bridge(sys.argv[1], sys.argv[2:])

    bridge.start()






    #listsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)      #
    #listsocket.listen(10)                                               #

    #listsocket.sendto(data, ('<broadcast>', PORT))                      # port?
    sockets = []    
    print("ID: " + bridge.b_id)
    print 'LANS: ' 
    print (bridge.lans)

    # creates sockets and connects to them
    for x in range(len(bridge.lans)):
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.connect(pad(bridge.lans[x]))
        sockets.append(s)
    print "Bridge " + bridge.b_id + " starting up\n"
    
    # Main loop
    while True:

        send bpdu message to each port every 500ms


        if bpdu message received:
            if src in bpdutable:
                update last_seen time for this bpdu
            else if not there:
                add to table and self destroy in 750 ms
            checkForRoot()
            updateBpduTable()

        BPDU table: source, port, last_seen






        last_time = time.time()
        for s in sockets:
            if ((last_time - time.time()) < 500) :
                msg = {"source":bridge.b_id, "dest":"ffff", "type": "bpdu", "message":{"id":"92b4", "root":bridge.root, "cost":0, "port":bridge.port}}
                s.send(json.dumps(msg))
                print 'Bridge %s is sending a message' % bridge.b_id
                bridge.bpdu.append(msg)

        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(sockets, [], [], 1)
        print 'RECEIVING AT : %s' % bridge.b_id 
        # Reads from each fo the ready sockets
        for x in ready:
            data = x.recv(1500)
            data_json = json.loads(data)
            if (data_json['type'] == 'bpdu'):
                print 'BPDU!!!!!'
                port = x.getpeername()
                print 'SOCKET PORT: %s' % port
                add_bpdu(bridge, data_json, port)
        bridge.print_ft()
