#!/usr/bin/python -u    
# -*- coding: utf-8 -*-
# The -u makes output unbuffered, so it will show up immediately
import json
import sys
import socket
import select
import struct
import time
class Bridge(object):

    def __init__(self, b_id, lans):
        self.b_id = b_id
        self.lans = lans
        self.active_ports = map(self.parse_lan, self.lans)#{port: destination bridge}
        self.ports = {}
        self.start = 0
        self.stop = 0
        self.forwarding_table = {}                              # {"<destination>": "<port>"}
        self.bpdus = {}                                         #{<socket>: {"source" :{"root": "2", "cost": 1, "timestamp": FFF} } }
        self.root = {"id": b_id, "root_port": -1, "cost": 0}
        self.connected_bridges = [] ####??????????
        # {"1": {"4": {{"root": 3, "cost": 1, "timestamp": 4}},
        #        {"5": {"root": 3, "cost": 3, "timestamp": 4}},
        #   "2" : {"1": {"root": 3, "cost": 1, "timestamp": 4}
        # }}


    #def add_bpdu(self, socket, data_json):
        # be fancy here
        #self.bpdus[socket] = {data_json['source']: {"root": data_json['message']['root'], "cost": data_json['message']['cost'], "timestamp": time.time()} }

    def parse_lan(self, l):
        return l.replace('\x00', '')

    def send_bpdu(self, s):
        message = {"source":self.b_id, "dest":"ffff", "type": "bpdu", "message":{"id":"92b4", "root":self.root["id"], "cost":self.root["cost"], "port": s.getpeername().replace('\x00', '')}}
        s.send(json.dumps(message))
        #print "BPDU message sent: %s" % json.dumps(message)

    def remove_duplicates(self, l):
        s = []
        for i in l:
            if i not in s:
                s.append(i)
        return s

    def create_stp(self):
        current_root = self.root["id"]
        current_cost = self.root["cost"]
        current_root_port = self.root["root_port"]
        new_bpdus = self.bpdus.copy()
        current_active_ports = []
        replace_bpdus = False
        did_root_change = False
        print "===> bpdu table: %s" %  (json.dumps(self.bpdus))
        # CHOOSING A ROOT 
        for socket, bpdus in self.bpdus.iteritems():
            # CREATING A HARD COPY IN ORDER TO AVOID CHANGES BUT WHY IS THIS HAPPENING????????????
            bpdus_copy = bpdus.copy()
            for source, bpdu in bpdus_copy.iteritems():
                if ((int(round(time.time() * 1000)) - int(round(bpdu["timestamp"] * 1000))) >= 750):
                    #print "DELETE %s from %s ===> " %(json.dumps(new_bpdus[socket].pop(source, None)), json.dumps(bpdu))
                    replace_bpdus = True
                else:
                    #if (current_root < bpdu["root"]):
                        #print "This Bridge root id %s is less than new one %s" %(self.root["id"], bpdu["root"])
                    #elif ((current_root == bpdu["root"])  and (current_cost < bpdu["cost"])):
                        #print "This Bridge cost %s is less than new one %s" %(self.root["cost"], bpdu["cost"])
                    #elif ((current_root == bpdu["root"]) and (current_cost == bpdu["cost"]) and (self.b_id < source, 16) ):
                        #print "This Bridge id is less than new one"
                    if ((current_root > bpdu["root"]) or ((current_root == bpdu["root"]) and (current_root_port > socket))) :
                        current_root = bpdu["root"]
                        current_cost = bpdu["cost"] + 1
                        current_root_port = socket
        # If this birdge is not a root, change this bridge's root, cose, and ports statuses
        if (self.root["id"] != current_root):
            print "OLD root: %s" % json.dumps(self.root)
            #print "New root: %s/%s" % (current_root, current_cost)
            #print "old root %s, new root: %s" % (self.root["id"], current_root)
            self.root["id"] = current_root
            self.root["cost"] = current_cost
            self.forwarding_table = {}
            current_active_ports = []
            print "New root: %s/%s\n" % (self.b_id, self.root["id"])

            if (self.root["root_port"] != current_root_port):
                #self.active_ports.remove(self.root["root_port"])
                #self.forwarding_table = {}
                self.root["root_port"] = current_root_port
                print "Root port: %s/%s\n" % (self.b_id, self.root["root_port"])
            did_root_change = True

        if replace_bpdus:
            replace_bpdus = False
            self.bpdus = new_bpdus

       ## KEEPING DESIGNATED PORTS
        # {"1": {"4": {{"root": 3, "cost": 1, "timestamp": 4}},
        #        {"5": {"root": 3, "cost": 3, "timestamp": 4}},
        #   "2" : {"1": {"root": 3, "cost": 1, "timestamp": 4}
        # }}
        # IF IM A ROOT
        if (self.b_id == self.root["id"]):
            # IF I BECAME A ROOT
            if (self.root["root_port"] != -1):
                print "I'm here"
                current_active_ports = map(self.parse_lan, self.lans)
                self.root["root_port"] = -1
            else:
                current_active_ports = self.remove_duplicates(self.active_ports)
                print "Designated ports: %s/%s" % (self.b_id, ','.join(current_active_ports))

        # ONLY IF IM NOT A ROOT

        #{"45ad": {{"1": "bpdu1"}, {"2"; "bpdu2"}}}
           # lowest_cost_through_this_port = {"port": -1, "cost": -1}
            # for source, ports in sources:
            #     if len(ports) > 1:
            #         for port, bpdu in ports:
            #             if (bpdu["root"] != self.root["root_port"]):
            #                 if ( (lowest_cost_through_this_port["cost"] == -1) or (bpdu["cost"] < lowest_cost_through_this_port["cost"]) ):
            #                     lowest_cost_through_this_port["port"] = port
            #                     lowest_cost_through_this_port["cost"] = bpdu["cost"]
            #                     self.active_ports.append(port)
        else:
            sources = {}
            for port, bpdus in self.bpdus.iteritems():
                bpdus_copy = bpdus.copy()
                for source, bpdu in bpdus.iteritems():
                    if (source in sources):
                        sources[source][port] = bpdu
                    else:
                        portConnected = {}
                        portConnected[port] = bpdu
                        sources[source] = portConnected

            #lowest_cost_through_this_port = {"port": -1, "cost": -1}

            current_active_ports.append(self.root["root_port"])


            #for socket, bpdus in self.bpdus.iteritems():
            print "BPDU: %s" % json.dumps(self.bpdus)
            print "SOURCES: %s" % json.dumps(sources)
            for source_id, ports in sources.iteritems():
            #         for port, bpdu in ports:
            #             if (bpdu["root"] != self.root["root_port"]):
            #                 if ( (lowest_cost_through_this_port["cost"] == -1) or (bpdu["cost"] < lowest_cost_through_this_port["cost"]) ):
            #                     lowest_cost_through_this_port["port"] = port
            #                     lowest_cost_through_this_port["cost"] = bpdu["cost"]
            #                     self.active_ports.append(port)
                for port, bpdu in ports.iteritems():
                    if (bpdu["root"] != self.root["root_port"]):
                        #if (port not in current_active_ports)
                        if (len(ports) > 1):
                            if (self.root["cost"] > bpdu["cost"]):
                                print "Disabled port: %s/%s\n" % (self.b_id, port)
                            elif ((self.root["cost"] < bpdu["cost"]) or ((self.root["cost"] == bpdu["cost"]) and (self.b_id < source_id))):
                                if (port not in current_active_ports):
                                    current_active_ports.append(port)
                            # if ( (lowest_cost_through_this_port["cost"] == -1) or (bpdu["cost"] < lowest_cost_through_this_port["cost"]) ):
                            #     print "HERE"
                            #     lowest_cost_through_this_port["port"] = port
                            #     lowest_cost_through_this_port["cost"] = bpdu["cost"]

                            # if ( (bpdu["cost"] == lowest_cost_through_this_port["cost"]) and (source_id < self.b_id) ):
                            #     if (port not in current_active_ports):
                            #         current_active_ports.append(port)
                        #if (bpdu["cost"] - 1 == self.root["cost"]):
                            # means it go through me and i should keep the port as designated port
                            # if socket not in current_active_ports:
                            #     print "added"
                            #     current_active_ports.append(socket)
                            # elif (source < self.b_id):
                            #     print "added 2"
                            #     current_active_ports.append(socket)
                            # break
            for p in self.ports:
                if ((p not in self.bpdus) and (p not in current_active_ports) and (p != self.root["root_port"])):
                    #print "This port did not receive BPDU"
                    print "Designated port: %s/%s\n" % (self.b_id, p)
                    current_active_ports.append(p)
                else:
                    print "Disabled port: %s/%s\n" % (self.b_id, p)

        self.active_ports = current_active_ports
        #print "%s rootport: %s, active port: %s" % (self.b_id, self.root["root_port"], ','.join(self.active_ports))

        return did_root_change
            ## HOW figure out port states

    def add_to_forwarding_table(self, source, port):
        self.forwarding_table[source] = {"port": port, "timestamp": time.time()}

    def process_data(self, port, data):
        #print "Forwarding table: %s" % json.dumps(self.forwarding_table)
        if port in self.active_ports:
            print "Received message %s on port %s from %s to %s\n" % (data["message"]["id"], port, data["source"], data["dest"])
        if (data["dest"] in self.forwarding_table):
            # We should "timeout" forwarding table entries 5 seconds after receiving the last message from that address.
            if ((round(time.time()) - self.forwarding_table[data["dest"]]["timestamp"]) < 5):
                port_to_dest = self.forwarding_table[data["dest"]]["port"]
                print "Forwarding table: %s" % json.dumps(self.forwarding_table)
                print "Active ports: %s" % self.active_ports
                if ((port_to_dest in self.active_ports) and (port_to_dest != port)):
                    print "Forwarding message %s to port %s\n" % (data["message"]["id"], port_to_dest)
                    (self.ports[port_to_dest]).send(json.dumps(data))
                else:
                    print "Not forwarding message %s\n" % data["message"]["id"]
            else:
                for p in self.active_ports:
                    if p != port:
                        print "Broadcast message %s to all ports %s\n" % (data["message"]["id"], p)
                        (self.ports[p]).send(json.dumps(data))
                
        else:
            for p in self.active_ports:
                if p != port:
                    print "Broadcast message %s to all ports %s\n" % (data["message"]["id"], p)
                    (self.ports[p]).send(json.dumps(data))
        self.add_to_forwarding_table(data["source"], port)

    def add_bpdu(self, socket, data_json):
        # be fancy here
        # if the socket exists
        if socket in self.bpdus:
            self.bpdus[socket][data_json['source']] = {"root": data_json['message']['root'], "cost": data_json['message']['cost'], "timestamp": time.time()}
        else:
            self.bpdus[socket] = {data_json['source']: {"root": data_json['message']['root'], "cost": data_json['message']['cost'], "timestamp": time.time()} }                      # CHECK THIS
        self.create_stp()

    def start_bridge(self):
        sockets = []
        last_sent = 0;
        did_root_change = False
        bpdu_received = False
        # creates sockets and connects to them
        for x in range(len(self.lans)):
            s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            s.connect(pad(self.lans[x]))
            port = s.getpeername().replace('\x00', '')
            # An object to relate port numbers and socket objects
            self.ports[port] = s
            sockets.append(s)
        print "Bridge " + self.b_id + " starting up\n"    
        
        while True:
            ready, ignore, ignore2 = select.select(sockets, [], [], 0.1)
            # Reads from each fo the ready sockets
            for x in ready:
                #checkForTimedoutBPDUs
                data = x.recv(1500)
                port = x.getpeername().replace('\x00', '')
                self.ports[port] = x
                data_json = json.loads(data)
                # If received packet is of type BPDU, add it to bpdu table
                if (data_json['type'] == 'bpdu'):
                    bpdu_received = True
                    self.add_bpdu(port, data_json)
                # If received packet is of type Data, process this data
                elif (data_json['type'] == 'data'):
                    self.process_data(port, data_json)
                else:
                    print "ERROR: unknown data type"
            # WHENEVER YOU RECEIVE A NEW BPDU -> REBUILD THE TREE
            if (bpdu_received):
                did_root_change = self.create_stp()
            # Broadcast BPDU message every 500ms or if the root has changed
            if (did_root_change or (int(round(time.time() * 1000)) - last_sent) >= 500):
                for s in sockets:
                    self.send_bpdu(s)
                last_sent = int(round(time.time()) * 1000)

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

if __name__ == "__main__":
    bridge = Bridge(sys.argv[1], sys.argv[2:])
    bridge.start_bridge()
