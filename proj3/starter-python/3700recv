#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code

import sys
import socket
import time
import datetime
import select
import json
import struct
import hashlib
import struct 

MSG_SIZE = 1500
TIMEOUT = 30

SEQUENCE = 0
ADV_W = 1

# Bind to localhost and an ephemeral port
UDP_IP = "127.0.0.1"
UDP_PORT = 0


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(TIMEOUT)

LAST_SEQ_RECV = 0
# Get port we bound to
UDP_PORT = sock.getsockname()[1]
log("[bound] " + str(UDP_PORT))

class Receiver(object):
    
    def __init__(self):
        self.last_byte_rcv = 0
        self.next_byte_expected = 0
        self.data_rcv = ""    
        self.buffered_segments = {}  # {<seq_number>: {"data": String, "buffered": Boolean} }
        self.sack = []
        self.addr = 0
    ## Check if this data came in order
    def in_order(self, packet):
        return True
    
    # send ACKs to sender
    def send_ack(self):
        msg = struct.pack("!LB", self.next_byte_expected, True)
        log("[ABOUT TO SEND ACK]=" + str(self.next_byte_expected))
        if sock.sendto(msg, self.addr) < len(msg):
            log("[error] unable to fully send packet")
    
    # send Duplicate ACKs
    # def send_dack(self, time, address):
    #     msg= struct.pack("!Ld", self.next_byte_expected, time)
    #     #msg = json.dumps({"ack": seq + 1, "time": time})
    #     log("[ABOUT TO SEND DACK : expected seq:=]" + str(self.next_byte_expected))
    #     if sock.sendto(msg, address) < len(msg):
    #         log("[error] unable to fully send packet")
    
    # check if the sequence filled the gaps
    def check_gaps(self, next_byte):
        if next_byte in self.sack:
            self.sack.remove(next_byte)
            new_next_byte = next_byte + len(self.buffered_segments[next_byte]["data"])
            return check_gaps(new_next_byte)
        else:
            return new_next_byte

    def digest_data(self, data):
        s = ""
        for d in data: 
            s += str(d)
        log("[check digested]=" + str(s) + "for data=" + str(data))
        return hashlib.md5(s).digest()

    def check_data(self, packet):
        flags = (packet["eof"] << 1) + packet["ack"]
        recv_hash = digest_data([packet["sequence_number"], flags, packet["data"])
        return packet["checksum"] == recv_hash

    # def process_corrupted_data(self, packet):
    #     log("[CORRUPTED] " + str(packet["sequence_number"]))
    #     self.send_dack(self.next_byte_expected, packet["timestamp"])
        
    # def process_out_of_order_data_segment(packet):
    #     log("[OUT OF ORDER] " + str(packet["sequence_number"]))
    #     self.send_dack(packet["timestamp"])
        #self.buffered_segments.add(packet)

        # Also, we CANNOT assume that all currently buffered segments
        # have sequence number lower than the one that just arrived.
        #self.last_byte_rcv = max(self.last_byte_rcv, packet["sequence_number"] + len(packet["data"]) - 1)

        # should we reduce our window?? even though we are not using it yet.. 
        # self.rcv_window = self.max_rcv_window - (self.last_byte_rcv - self.next_byte_expected)
        #ack = {"adv_w": self.rcv_window, "sequence_number": self.next_byte_expected, timestamp: -1} # -1 or what?

    ## Process this data
    ## data structure: (seq, ack, eof, time, hash, data)
    def process_data(self, packet):

        if (self.check_data(packet)):
            self.buffered_segments[packet["sequence_number"]]["data"] = packet["data"]
            self.buffered_segments[packet["sequence_number"]]["buffered"] = True
            # if it's in order
            if (packet["sequence_number"] == self.next_byte_expected): #(self.last_byte_rcv + 1 == seq):
                log("[recv data] " + str(packet["sequence_number"]) + " (" + len(str(packet["data"])) + ") ACCEPTED (in-order)")
                self.next_byte_expected = self.check_gaps(packet["sequence_number"] + len(packet["data"])) 
                #if (len(self.buffered_segments) < 0):
                    # No previously buffered segments.
                    #self.last_byte_rcv = segment["sequence_number"] + len(segment["data"]) - 1;
                #else:
                    # Some segments were previously buffered.
                    # Checked whether this segment filled any gaps for
                    # the possible buffered segments.  If yes,
                    # this will update "last_byte_recv"
                    #self.check_buffered()


                # ack = {adv_w: current_rcv_w, sequence_number: next_byte_expected, timestamp: segment["timestamp"]}
                self.send_ack()
            # if out of order - send DACKs
            else:
                self.sack.append(packet["sequence_number"])
                log("[recv data] " + str(packet["sequence_number"]) + " (" + len(str(packet["data"])) + ") ACCEPTED (OUT of order)")
                self.send_ack()
                #self.process_out_of_order_data_segment(packet)
                # self.send_dack(self.last_byte_rcv, time, addr)
    
        # if the data is corrupted - send dack 
        else:
            self.send_ack()
            # log("[CORRUPTED] " + str(seq))
            #self.process_currupted_data(packet)
            # self.send_dack(self.last_byte_rcv, time, addr)


def decode(data):
    unpack_format = "!LH16s" #sequence, flag, hash   
    head_size = struct.calcsize(unpack_format)
    header = data[:head_size]
    body = data[head_size:]
    log("[original data]=" + data + " header size=" + str(head_size) + " header=" + header + " body=" + body)
    unpacked = struct.unpack(unpack_format, header)
    log("[received unpacked data]=" + str(unpacked))
    sequence_number, flags, data_check = unpacked
    eof = flags >> 1       # unpacking
    ack = flags & 1
    log("[sequence_number]=" + str(sequence_number) + " ack=" + str(ack) + " eof=" + str(eof)  + " data_check=" + data_check)
    data_segment = { "sequence_number": sequence_number, 
                    "ack": ack,
                    "eof": eof,
                    "checksum": data_check,
                    "data": body
                    }
    log("[data segment]=" + json.dumps(data_segment))
    return data_segment

r = Receiver()
# Now listen for packets
while True:
    result = sock.recvfrom(MSG_SIZE)

    # If nothing is ready, we hit the timeout
    if result:
        #(seq, ack, eof, time, hash, data)
        
        (res, addr) = result
        r.addr = addr

        decoded = decode(res)
        '''
        ** assume sender will send a hexdigested hash already instead of an entire obj
        '''
        try:
            #decoded = json.loads(data)
            #print decoded
            # If the EOF flag is set, exit
            if (decoded["eof"]):#(decoded['eof']):
                log("[completed]")
                sys.exit(0)

            # If there is data, we accept it and print it out
            if (decoded["data"]):#(decoded['data']):
                # If we receive data, we assume it's in-order
                r.process_data(decoded);

        except (ValueError, KeyError, TypeError) as e:
            log("[recv corrupt packet]")
            raise e
    else:
        log("[error] timeout")
        sys.exit(-1)
