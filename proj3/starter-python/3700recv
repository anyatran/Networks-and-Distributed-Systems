#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code

import sys
import socket
import time
import datetime
import select
import json
import struct
import hashlib
import struct 

MSG_SIZE = 1500
TIMEOUT = 30

SEQUENCE = 0
ADV_W = 1

# Bind to localhost and an ephemeral port
UDP_IP = "127.0.0.1"
UDP_PORT = 0


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(TIMEOUT)

LAST_SEQ_RECV = 0
# Get port we bound to
UDP_PORT = sock.getsockname()[1]
log("[bound] " + str(UDP_PORT))

class Receiver(object):
    
    def __init__(self):
        self.last_byte_rcv = 0
        self.data_rcv = ""    

    ## Check if this data came in order
    def in_order(self, packet):
        return True
    
    # send ACKs to sender
    def send_ack(self, seq, time,  address):
        # ****** INCREMENT BY 1
        msg = json.dumps({"ack": seq + 1, "time": time}) #({"ack": decoded['sequence'] + len(decoded['data']) + 1})
        # format: ABOUT TO SEND <current sequence> + <data.length>
        log("ABOUT TO SEND ACK" + msg)
        if sock.sendto(msg, address) < len(msg):
            log("[error] unable to fully send packet")
    
    # send Duplicate ACKs
    def send_dack(self, seq, time, address):
        msg = json.dumps({"ack": seq + 1, "time": time})
        log("ABOUT TO SEND DACK " + msg)
        if sock.sendto(msg, address) < len(msg):
            log("[error] unable to fully send packet")


    ## Process this data
    ## data structure: (seq, ack, eof, time, hash, data)
    def process_data(self, packet, addr):
        # verify for the data first
        seq = packet[0]
        ack = packet[1]
        eof = packet[2]
        time = packet[3]
        hashcode = packet[4]
        data = packet[5]
        recv_hash = hashlib.md5(data)
        # if it's the same data and nothing has been lost
        if (hashcode == recv_hash.hexdigest()):
            # if it's in order
            if (self.last_byte_rcv + 1 == seq):
                log("[recv data] " + str(seq) + " (" + str(data) + ") ACCEPTED (in-order)")
                self.last_byte_rcv = seq + len(data)
                #send ACKKKKKKKKKKK
                sys.stdout.write(data)
                self.data_rcv += data
                self.send_ack(self.last_byte_rcv, time, addr)
            # if out of order - send DACKs
            else:
                self.send_dack(self.last_byte_rcv, time, addr)
    
        # if the data is corrupted - send dack 
        else:
            log("[CORRUPTED] " + str(seq))
            self.send_dack(self.last_byte_rcv, time, addr)
        #else:
            ##++++ send ACK (last byte acked - sequence), SACK (this data sequence)
            ##???? if we recieved package (#4), how do we know that we received package (#3) already and that we sacked it 
            # msg = json.dumps({"ack": SEQUENCE, "sack": decoded['sequence'] + len(decoded['data'])}, )
            # log("[recv data] " + str(packet['sequence']) + " (" + str(len(packet['data'])) + ") ACCEPTED (out-order)")
    #else:
        #####??????????? What to do if checksum is invalid
        # log("[recv data] " + str(packet['sequence']) + " (" + str(len(packet['data'])) + ") IGNORED")
        ## OR
        # log("[recv corrupt packet]")

# Now listen for packets
while True:
    res = sock.recvfrom(MSG_SIZE)
    '''
    need to unpack the result first
    - need the format: WAITING FOR YULIAAAAAAA
    '''
    unpack_format = ""
    result = struct.unpack(unpack_format, res)
    # If nothing is ready, we hit the timeout
    if result:
        #(seq, ack, eof, time, hash, data)
        data = result
        addr = res
        '''
        ** assume sender will send a hexdigested hash already instead of an entire obj
        '''
        try:
            #decoded = json.loads(data)
            #print decoded
            # If the EOF flag is set, exit
            if (data[3]):#(decoded['eof']):
                log("[completed]")
                sys.exit(0)

            # If there is data, we accept it and print it out
            if (data[5]):#(decoded['data']):
                # If we receive data, we assume it's in-order
                process_data(result, addr);

        except (ValueError, KeyError, TypeError) as e:
            log("[recv corrupt packet]")
            raise e
    else:
        log("[error] timeout")
        sys.exit(-1)
