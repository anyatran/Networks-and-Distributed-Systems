#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code

import sys
import socket
import time
import datetime
import select
import json
import struct
import hashlib
import struct 

MSG_SIZE = 1500
TIMEOUT = 30

SEQUENCE = 0
ADV_W = 1

# Bind to localhost and an ephemeral port
UDP_IP = "127.0.0.1"
UDP_PORT = 0


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(TIMEOUT)

LAST_SEQ_RECV = 0
# Get port we bound to
UDP_PORT = sock.getsockname()[1]
log("[bound] " + str(UDP_PORT))

class Receiver(object):
    
    def __init__(self):
        self.last_byte_rcv = 0
        self.next_byte_expected = 0
        self.data_rcv = ""    
        self.buffered_segments = []

    ## Check if this data came in order
    def in_order(self, packet):
        return True
    
    # send ACKs to sender
    def send_ack(self, time,  address):
        msg = struct.pack("!Ld", self.next_byte_expected, time)
        #msg = json.dumps({"ack": next_seq, "time": time}) #({"ack": decoded['sequence'] + len(decoded['data']) + 1})
        # format: ABOUT TO SEND <current sequence> + <data.length>
        log("ABOUT TO SEND ACK" + self.next_byte_expected)
        if sock.sendto(msg, address) < len(msg):
            log("[error] unable to fully send packet")
    
    # send Duplicate ACKs
    def send_dack(self, time, address):
        msg= struct.pack("!Ld", self.next_byte_expected, time)
        #msg = json.dumps({"ack": seq + 1, "time": time})
        log("ABOUT TO SEND DACK : expected seq: " + str(self.next_byte_expected))
        if sock.sendto(msg, address) < len(msg):
            log("[error] unable to fully send packet")


    def check_data(self, packet):
        recv_hash = hashlib.md5(packet["data"])
        return packet["hash_check"] == recv_hash.hexdigest()

    def process_corrupted_data(self, packet, addr):
        log("[CORRUPTED] " + str(packet["sequence_number"]))
        self.send_dack(self.next_byte_expected, packet["timestamp"], addr)
        
    def process_out_of_order_data_segment(packet, addr):
        log("[OUT OF ORDER] " + str(packet["sequence_number"]))
        self.send_dack(packet["timestamp"], addr)
        #self.buffered_segments.add(packet)

        # Also, we CANNOT assume that all currently buffered segments
        # have sequence number lower than the one that just arrived.
        #self.last_byte_rcv = max(self.last_byte_rcv, packet["sequence_number"] + len(packet["data"]) - 1)

        # should we reduce our window?? even though we are not using it yet.. 
        # self.rcv_window = self.max_rcv_window - (self.last_byte_rcv - self.next_byte_expected)
        #ack = {"adv_w": self.rcv_window, "sequence_number": self.next_byte_expected, timestamp: -1} # -1 or what?

    ## Process this data
    ## data structure: (seq, ack, eof, time, hash, data)
    def process_data(self, packet, addr):

        if (check_data(packet)):
            # if it's in order
            if (packet["sequence_number"] == self.next_byte_expected): #(self.last_byte_rcv + 1 == seq):
                log("[recv data] " + str(seq) + " (" + str(data) + ") ACCEPTED (in-order)")
                self.next_byte_expected = packet["sequence_number"] + len(packet["data"]) ## 
                
                #if (len(self.buffered_segments) < 0):
                    # No previously buffered segments.
                    #self.last_byte_rcv = segment["sequence_number"] + len(segment["data"]) - 1;
                #else:
                    # Some segments were previously buffered.
                    # Checked whether this segment filled any gaps for
                    # the possible buffered segments.  If yes,
                    # this will update "last_byte_recv"
                    #self.check_buffered()


                # ack = {adv_w: current_rcv_w, sequence_number: next_byte_expected, timestamp: segment["timestamp"]}
                self.send_ack(time, addr)
            # if out of order - send DACKs
            else:
                self.process_out_of_order_data_segment(packet, addr)
                # self.send_dack(self.last_byte_rcv, time, addr)
    
        # if the data is corrupted - send dack 
        else:
            # log("[CORRUPTED] " + str(seq))
            self.process_currupted_data(packet, addr)
            # self.send_dack(self.last_byte_rcv, time, addr)


def decode(data):
    unpack_format = "!LBBd32s" # time is a double    
    head_size = struct.calcsize(unpack_format)
    header = data[:head_size]
    body = data[head_size:]
    log("original data=" + data + " header size=" + str(head_size) + " header=" + header + " body=" + body)
    unpacked = struct.unpack(unpack_format, header)
    log("[received unpacked data]=" + unpacked)
    sequence_number, ack, eof, timestamp, data_check = unpacked
    log("sequence_number=" + str(sequence_number) + " ack=" + str(ack) + " eof=" + str(eof) + " timestamp=" + str(timestamp) + " data_check=" + data_check)
    data_segment = { "sequence_number": sequence_number, 
                    "ack": ack,
                    "eof": eof,
                    "timestamp": timestamp,
                    "hash_check": data_check,
                    "data": body
                    }
    log("[data segment]=" + json.dumps(data_segment))
    return data_segment

# Now listen for packets
while True:
    result = sock.recvfrom(MSG_SIZE)

    # If nothing is ready, we hit the timeout
    if result:
        #(seq, ack, eof, time, hash, data)
        
        (res, addr) = result

        decoded = decode(res)
        '''
        ** assume sender will send a hexdigested hash already instead of an entire obj
        '''
        try:
            #decoded = json.loads(data)
            #print decoded
            # If the EOF flag is set, exit
            if (decoded["eof"]):#(decoded['eof']):
                log("[completed]")
                sys.exit(0)

            # If there is data, we accept it and print it out
            if (decoded["data"]):#(decoded['data']):
                # If we receive data, we assume it's in-order
                process_data(decoded, addr);

        except (ValueError, KeyError, TypeError) as e:
            log("[recv corrupt packet]")
            raise e
    else:
        log("[error] timeout")
        sys.exit(-1)
