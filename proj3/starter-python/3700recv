#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code

import sys
import socket
import time
import datetime
import select
import json
import struct
import hashlib
import struct 

MSG_SIZE = 1500
TIMEOUT = 30
MSS = 1478
SEQUENCE = 0
ADV_W = 1

# Bind to localhost and an ephemeral port
UDP_IP = "127.0.0.1"
UDP_PORT = 0


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(TIMEOUT)

LAST_SEQ_RECV = 0
# Get port we bound to
UDP_PORT = sock.getsockname()[1]
log("[bound] " + str(UDP_PORT))

class Receiver(object):
    
    def __init__(self):
        self.data = ""
        self.last_byte_rcv = 0
        self.next_byte_expected = 0
        self.buffered_segments = {}  # {<seq_number>: {"data": String, "buffered": Boolean} }
        self.sack = []
        self.addr = 0
        self.ordered_seq = []
    
    # send ACKs to sender
    def send_ack(self, sequence_number):
        msg = struct.pack("!LB", sequence_number, True)
        log("[SENDING ACK] seq_n=" + str(sequence_number))
        if sock.sendto(msg, self.addr) < len(msg):
            log("[error] unable to fully send packet")

    def digest_data(self, data):
        s = ""
        for d in data: 
            s += str(d)
        #log("[check digested]=" + str(s) + "for data=" + str(data))
        return hashlib.md5(s).digest()

    def check_data(self, packet):
        flags = (packet["eof"] << 1) + packet["ack"]
        recv_hash = self.digest_data([packet["sequence_number"], flags, packet["data"]])
        log("[check_data]=" + str(packet["checksum"] == recv_hash))
        return packet["checksum"] == recv_hash

    ## Process this data
    ## data structure: (seq, ack, eof, time, hash, data)
    def process_data(self, packet):

        if (self.check_data(packet)):
            self.send_ack(packet["sequence_number"])

            if (packet["sequence_number"] not in self.buffered_segments):
                self.buffered_segments[packet["sequence_number"]] = {"data": "", "next_byte": 0, "buffered": False}

            if not self.buffered_segments[packet["sequence_number"]]["buffered"]:
                self.buffered_segments[packet["sequence_number"]]["data"] = packet["data"]
                self.buffered_segments[packet["sequence_number"]]["buffered"] = True
                if (packet["sequence_number"] == self.next_byte_expected): #(self.last_byte_rcv + 1 == seq):
                    log("[recv data] " + str(packet["sequence_number"]) + " (" + str(len(packet["data"])) + ") ACCEPTED (in-order)")
                
                    while ((self.next_byte_expected in self.buffered_segments) and (self.buffered_segments[self.next_byte_expected]["buffered"])):
                        self.data += self.buffered_segments[self.next_byte_expected]["data"]
                        sys.stdout.write(self.buffered_segments[self.next_byte_expected]["data"])
                        self.next_byte_expected += 1


def decode_data(data):
    unpack_format = "!LH16s" #sequence, flag, hash   
    head_size = struct.calcsize(unpack_format)
    header = data[:head_size]
    body = data[head_size:]
    #log("[original data]=" + str(data) + " header size=" + str(head_size) + " header=" + str(header) + " body=" + str(body))
    unpacked = struct.unpack(unpack_format, header)
    #log("[received unpacked data]=" + str(unpacked))
    sequence_number, flags, data_check = unpacked
    eof = flags >> 1       # unpacking
    ack = flags & 1
    log("[sequence_number]=" + str(sequence_number) + " ack=" + str(ack) + " eof=" + str(eof)  + " data_check=" + str(data_check))
    data_segment = { "sequence_number": sequence_number, 
                    "ack": ack,
                    "eof": eof,
                    "checksum": data_check,
                    "data": body
                    }
    # log("[data segment]=" + json.dumps(data_segment))
    return data_segment

r = Receiver()
# Now listen for packets
while True:
    result = sock.recvfrom(522)

    # If nothing is ready, we hit the timeout
    if result:
        #(seq, ack, eof, time, hash, data)
        
        (res, addr) = result
        r.addr = addr

        decoded = decode_data(res)

       # try:
            #decoded = json.loads(data)
            #print decoded
            # If the EOF flag is set, exit
        if (decoded["eof"]):#(decoded['eof']):
            log("[completed]")
            r.process_data(decoded)
            sys.exit(0)

            # If there is data, we accept it and print it out
        elif (decoded["data"]):#(decoded['data']):
                # If we receive data, we assume it's in-order
            r.process_data(decoded)

        #except (ValueError, KeyError, TypeError) as e:
         #   log("[recv corrupt packet]")
          #  raise e
    else:
        log("[error] timeout")
        sys.exit(-1)
