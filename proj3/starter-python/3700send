#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#
# NEW RENO: http://research.ijcaonline.org/volume40/number12/pxc3877351.pdf
# SACK: http://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/

import sys
import socket
import time
import datetime
import select
import json
import hashlib
import struct
from threading import Timer, Thread, Lock

## Maximum segment size, in bytes. Same for both sending/receiving endpoints.
MSS = 1500 
DATA_LENGTH = MSS - 20 

TIMEOUT = 30

# EFFECTIVE_WINDOW = min(CONGESTION_WIN, ADV_WIN)
# STATE = 0 #0 = slow start, 1 = AI
ALPHA = 0.875

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)
# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


class Sender(object):

    def __init__(self):
        #Current congestion window size, in bytes.
        self.data = ""
        self.cong_window = 1
        '''Last advertised size of the currently available space in the receiver's buffer.'''
        self.recv_window = 65536
        self.last_byte_sent = 0
        self.last_byte_acked = 0
        self.last_byte_sent_before_3dup_acks = -1
        self.sent_data = {} # entry = {<seq>: {sent: Boolean, timeout: int, sent_time: double}}
        self.acked_data = {}  # {<seq> : Boolean}
        self.RTT = 1.0 # one second
        '''
        The Slow-Start threshold is a dynamically-set value indicating
        an upper bound on the congestion window above which a
        TCP sender transitions from Slow-Start to the Congestion Avoidance
        state. The default value is 65535 bytes (or 64 KBytes).
        '''
        self.ssthresh = 65535

        self.dup_ack_thresh = 3
        '''
        Counter of duplicate acknowledgments.
        If the counter reaches three (3) or more dup-ACKs, the sender assumes
        that the oldest unacknowledged segment is lost and needs to be retransmitted. */
        '''
        self.dups_ack_count = {}

    def calc_timeout(self):
        # if (self.last_byte_sent in self.sent_data):
        #     old_timeout = self.sent_data[self.last_byte_sent]["timeout"]
        # else:
        #     old_timeout = self.RTT
        # new_timeout = (1 - ALPHA) * t + ALPHA * self.RTT
        log("[calculated_timeout]=" + str(2 * self.RTT))
        return 2 * self.RTT

    def digest_data(self, data):
        s = ""
        for d in data: 
            s += str(d)
        #log("[check digested]=" + str(s) + "for data=" + str(data))
        return hashlib.md5(s).digest()
   
    def calc_cong_window_after_new_ack(self):
        if (self.cong_window < self.ssthresh):
            self.cong_window = 2 * self.cong_window
            log("[slow start] congestion window=" + str(self.cong_window) + " ssthresh= " + str(self.ssthresh))
        else:
            self.cong_window += 1
            #self.cong_window = self.cong_window + self.cong_window / MSS
            log("[congestion avoidance] congestion window=" + str(self.cong_window) + " ssthresh= " + str(self.ssthresh))


    def fast_retransmit(self, packet):
        log("[fast retransmit] how did we get here????????")
        if (self.last_byte_sent_before_3dup_acks < 0):
            self.last_byte_sent_before_3dup_acks = self.last_byte_sent

        flight_size = self.last_byte_sent - self.last_byte_acked;
        ##??? check this
        self.ssthresh = flight_size / 2;
        self.ssthresh -= (self.ssthresh % MSS);
        self.ssthresh = max(self.ssthresh, 2 * MSS);

        self.cong_window = max(flight_size / 2, 2 * MSS) + 3 * MSS;

        ## ?? how to do this
        oldest_not_acked_segment = '123'
        sock.sendto(oldest_not_acked_segment, dest)

    def retransmit_packet(self, seqnum):
        if not self.acked_data[seqnum]:
            log("[retransmiting packet]=" + str(seqnum))
            self.transmit_packet(seqnum)

    def transmit_packet(self, seqnum):
        seq_num = (seqnum - self.first_byte)
        bytes = seq_num * DATA_LENGTH
        data = self.data[bytes : bytes + DATA_LENGTH]
        eof = False if seq_num != self.segments_number - 1 else True
        ack = False
        flags = (eof << 1) + ack
        digested = self.digest_data([seq_num, flags, data])
        tcp_header = struct.pack("!HH16s", seq_num, flags, digested)
        #log("[last byte sent]=" + str(self.last_byte_sent) + " ack=" + str(ack) + " eof=" + str(eof) + " segment check=" + str(digested) + " header_size=" + str(struct.calcsize("!LH16s")))
        #log("[tcp header]=" + tcp_header)
        packet = tcp_header + data
        sock.sendto(packet, dest)
        p = self.sent_data[seqnum]
        p['sent'] = True
        p['sent_time'] = time.time()
        p['timeout'] = self.calc_timeout()
        log("[send data] " + str(seq_num) + " (" + str(len(packet)) + ")")
        Timer(p['timeout'], self.retransmit_packet, [seqnum]).start()

    def effective_window(self):
        start = self.last_byte_sent
        end = self.last_byte_sent + self.cong_window
        if end > self.last_byte:
            end =  self.last_byte
        log("[window range]=" + str(range(start, end)))
        return range(start, end)

    def send_untransmitted(self):
        for segment in self.effective_window():
            if not self.sent_data[segment]['sent']:
                self.transmit_packet(segment)

    def dups_ack(self, data):
        if data["next_byte_expected"] in self.dups_ack_count:
            if self.dups_ack_count[data["next_byte_expected"]] == 2: # this is going to be the third dup ack
                self.retransmit_packet(data["next_byte_expected"])
                del self.dups_ack_count[data["next_byte_expected"]]
            else:
                self.dups_ack_count[data["next_byte_expected"]] += 1
        else:
            self.dups_ack_count[data["next_byte_expected"]] = 1

 
    def process_ack(self, data):
        rtt_estimate = time.time() - self.sent_data[data["sequence_number"]]['sent_time']
        self.RTT = ALPHA * rtt_estimate + (1 â€“ ALPHA) * (self.RTT)
        log("[RTT]=" + str(self.RTT))
        self.acked_data[data["sequence_number"]] = True
        self.calc_cong_window_after_new_ack()
        if data["sequence_number"] > data["next_byte_expected"]: # something is missing
            self.dups_ack(data)

        if data["sequence_number"] == self.last_byte_sent:
            log("[acked last byte sent]" + str(data["sequence_number"]))
            if(data["next_byte_expected"] == -1):
                self.finished_transmitting = True
            else: 
                while ((self.last_byte_sent in self.acked_data) and (self.acked_data[self.last_byte_sent])):
                    if self.last_byte_sent == self.last_byte - 1:
                        log("[finished transmitting]")
                        self.finished_transmitting = True
                    self.last_byte_sent += 1
                if not self.finished_transmitting:
                    self.send_untransmitted()

    def send(self):
        self.finished_transmitting = False
        self.segments_number = len(self.data) / DATA_LENGTH

        if len(self.data) % DATA_LENGTH: 
            self.segments_number += 1

        self.first_byte = self.last_byte_sent
        self.last_byte = self.last_byte_sent + self.segments_number

        self.populate_sent_data()
        self.populate_acked_data()

        self.send_untransmitted()

        # start looking for incoming acks
        while not self.finished_transmitting:
            # receive data struct and unpack into variables
            result = sock.recvfrom(MSS)

            if result:
                (data, addr) = result
                #try:
                decoded = decode(data)
                if decoded['ack']:
                    s.process_ack(decoded)
                #except (ValueError, KeyError, TypeError):
                 #   log("[recv corrupt packet]")
            else:
                log("[error] timeout")
                sys.exit(-1)

    def populate_sent_data(self):
        for x in range(self.first_byte, self.last_byte):
            self.sent_data[x] = {"sent": False, "timeout": 1.0}
        log("[populated data]" + json.dumps(self.sent_data))

    def populate_acked_data(self):
        for x in range(self.first_byte, self.last_byte):
            self.acked_data[x] = False
        log("[populated acked]" + json.dumps(self.acked_data))

        
def decode(data):
    unpack_format = "!HlB"  
    unpacked = struct.unpack(unpack_format, data)
    sequence_number, next_byte_expected, ack = unpacked    
    data_segment = { "sequence_number": sequence_number, "next_byte_expected": next_byte_expected, "ack": ack }
    log("[data segment]=" + json.dumps(data_segment))
    return data_segment

s = Sender()

def read_input():
    s.data = sys.stdin.read()
    log("[all data] length=" + str(len(s.data)))
    s.send()

read_input()

# Now read in data, send packets

# while True:
#     log("ABOUT TO SLEEP")
#     result = sock.recvfrom(MSS)

#     if result:
#         (data, addr) = result
#         #try:
#         decoded = decode(data)
#         if decoded['ack']:
#             s.process_ack(decoded)
#             if not self.finished_transmitting:
#                 s.send()
#         #except (ValueError, KeyError, TypeError):
#          #   log("[recv corrupt packet]")
#     else:
#         log("[error] timeout")
#         sys.exit(-1)

#sock.sendto(json.dumps({"src": 1, "dest": 2, "eof": True, "data": "", "sequence": SEQUENCE, "ack": False}), dest)
sys.exit(0)
