#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#
# NEW RENO: http://research.ijcaonline.org/volume40/number12/pxc3877351.pdf
# SACK: http://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/

import sys
import socket
import time
import datetime
import select
import json
import hashlib
import struct

## Maximum segment size, in bytes. Same for both sending/receiving endpoints.
MSS = 1000
all_data = ""

TIMEOUT = 30

# EFFECTIVE_WINDOW = min(CONGESTION_WIN, ADV_WIN)
# STATE = 0 #0 = slow start, 1 = AI
ALPHA = 0.875

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)
# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


class Sender(object):

    def __init__(self):
        #Current congestion window size, in bytes.
        self.cong_window = MSS
        '''Last advertised size of the currently available space in the receiver's buffer.'''
        self.recv_window = 65536
        #self.window = min(self.cong_window, self.recv_window)
        self.last_byte_sent = 0
        self.last_byte_acked = 0
        self.last_byte_sent_before_3dup_acks = -1
        self.sent_data = {} # entry = {<seq>: {sent: Boolean, timeout: int, sent_time: double}}
        self.acked_data = {}  # {<seq> : Boolean}
        self.RTT = 1.0 # one second
        '''
        The Slow-Start threshold is a dynamically-set value indicating
        an upper bound on the congestion window above which a
        TCP sender transitions from Slow-Start to the Congestion Avoidance
        state. The default value is 65535 bytes (or 64 KBytes).
        '''
        self.ssthresh = 65535

        self.dup_ack_thresh = 3
        '''
        Counter of duplicate acknowledgments.
        If the counter reaches three (3) or more dup-ACKs, the sender assumes
        that the oldest unacknowledged segment is lost and needs to be retransmitted. */
        '''
        self.dup_ack_count = 0

    ## ??? Where this data comes from????
    def send(self):
        #if (len(data) < 0):
            ## nothing to send...
        #else:
        if (len(all_data) > 0):

            ## 1. How many segments are currently unacknowledged
            flight_size = self.last_byte_sent - self.last_byte_acked
            ## 2. How many segments can still be sent - usable window
            effective_window = self.cong_window - flight_size ### or min(self.cong_window, self.recv_window)
            if (effective_window < 0):
                effective_window = 0
            log("[congestion window]=" + str(self.cong_window) + " [recv_window]=" + str(self.recv_window) + "[effective window]=" + str(effective_window) + "[flight size]=" + str(flight_size))
        
            burst_size = effective_window / MSS ##, ##remaining data - len(all_data[lastByteSent:])? / MSS);
            log("[burst size]=" + str(burst_size))

            if (burst_size > 0): 
                ## Send the "burstSize" worth of segments:
                i = 0
                while (i < burst_size) :
                    ##Extract one segment of data
                    packet = self.create_packet() 
                    log("[created this packet]=" + str(packet))

                    if sock.sendto(packet, dest) < len(packet):
                        log("[error] unable to fully send packet")
                    else:
                        log("[send data] " + str(self.last_byte_sent) + " (" + str(len(packet)) + ")")
                        timeout = self.calc_timeout()
                        self.sent_data[self.last_byte_sent] = {"sent": True, "timeout": timeout, "sent_time": time.time()}
                        self.acked[self.last_byte_sent] = False
                        self.last_byte_sent += MSS
                        log("[last byte sent after sending packet]=" + str(self.last_byte_sent))
                    i = i + 1

    def calc_timeout(self):
        if (self.last_byte_sent in self.sent_data):
            old_timeout = self.RTT
        else:
            old_timeout = self.sent_data[self.last_byte_sent]["timeout"]
        new_timeout = (1 - ALPHA) * old_timeout + ALPHA * self.RTT
        log("[calculated_timeout]=" + str(new_timeout))
        return new_timeout

    def digest_data(self, data):
        s = “”
        for d in data: 
            s += str(d)
        log("[check digested]=" + str(digested) + "for data=" + str(data))
        return hashlib.md5(s).digest()

    def create_packet(self):
        segment = all_data[self.last_byte_sent: self.last_byte_sent + MSS]
        eof = False
        ack = False
        flags = (eof << 1) + ack
        digested = self.digest_data([self.last_byte_sent, flags, segment])
        tcp_header = struct.pack("!LH16s", self.last_byte_sent, flags, digested)
        log("[last byte sent]=" + str(self.last_byte_sent) + " ack=" + str(ack) + " eof=" + str(eof) + " segment check=" + str(digested) + " header_size=" + str(struct.calcsize("!LH16s")))
        log("[tcp header]=" + tcp_header)
        data_packet = tcp_header + segment
        return data_packet
   
    def calc_cong_window_after_new_ask(self, sequence_number, last_acked):

        ## initial slow start:
        if (self.last_byte_sent_before_3dup_acks == -1):

            ## here check if there is any bytes of data that were not acked
            #if (self.last_byte_acked < self.last_byte_sent):
                ## calculate RTO here?
            #else:
                ## eveyrthing is acked, we are not waiting for any data to be acked!
            return self.cong_window + (sequence_number - last_acked - 1)
        else:
            # This is a slow start recovering after a segment loss
            # and before the sender has acknowledged all the segments
            # that were outstanding at the time 3x dupACKs were received,
            # the sender counts cumulative ACKs as worth only a single MSS.
            return self.cong_window + MSS;

    def process_new_ack(self, packet):
        # Update the Last-Byte-Acked param, but memorize the previous value
        last_byte_acked_previous = self.last_byte_acked;
        self.last_byte_acked = packet["sequence_number"] - 1;
        # Update congestion window
        self.cong_window = self.calc_cong_window_after_new_ask(packet["sequence_number"], last_byte_acked_previous);
        # ? also reset the counter of duplicate ACKs.
        self.dup_ack_count = 0;
        log("[processed new ack] last_byte_acked=" + str(self.last_byte_acked) + "congestion window=" + str(self.cong_window))
        ## To figure out next state:
        # if (self.cong_window < self.ssthresh):
            ## this is slow start
        # else:
            ## congestion avoidance

    def fast_retransmit(self, packet):
        log("[fast retransmit] how did we get here????????")
        if (self.last_byte_sent_before_3dup_acks < 0):
            self.last_byte_sent_before_3dup_acks = self.last_byte_sent

        flight_size = self.last_byte_sent - self.last_byte_acked;
        ##??? check this
        self.ssthresh = flight_size / 2;
        self.ssthresh -= (self.ssthresh % MSS);
        self.ssthresh = max(self.ssthresh, 2 * MSS);

        self.cong_window = max(flight_size / 2, 2 * MSS) + 3 * MSS;

        ## ?? how to do this
        oldest_not_acked_segment = '123'
        sock.sendto(oldest_not_acked_segment, dest)


    def process_dup_ack(self, packet):
        self.dup_ack_count = self.dup_ack_count + 1

        # If three duplicate ACKs -> fast retransmit
        if (self.dup_ack_count >= 3):
            self.fast_retransmit(packet)

        ## else do nothing :)

    def process_ack(self, packet):

        ## We are not using receiver's advirtised window yet but we MIGHT
        # self.recv_window = packet["ack_w"]

        self.RTT = time.time() - self.sent_data[packet["sequence_number"]]['sent_time']
        self.acked_data[packet["sequence_number"]] = True
        ## Is this a newly acknowledged segment (i.e., not a duplicate ACK)?
        log("[got ack with sequence number]=" + str(packet["sequence_number"]))
        log("[my last_byte_acked]=" + str(self.last_byte_acked))
        if (packet["sequence_number"] > self.last_byte_acked):

            ## figure out current state and process new ack accordingly
            self.process_new_ack(packet)

            # If all outstanding data at 3 dupACKs have been acked, reset the indicator parameter.
            if (self.last_byte_sent_before_3dup_acks <= self.last_byte_acked):
                self.last_byte_sent_before_3dup_acks = -1
            
        ## If duplicate ack
        else:
            ## figure out current state and process dup ack accordingly
            self.process_dup_ack(packet)
        log("[recv ack] " + packet["sequence_number"])

        


#calculates estimated timeout time based on RTTs
#Inputs: SampleRTT, old estimatedRTT, alpha
# def estimate_timeout(timestamp, old_rtt):
#     sample_rtt = time.time() - timestamp #current_time - timestamp
#     estimated_rtt = (1 - ALPHA) * old_rtt * (0.875 * ALPHA)
#     return estimated_rtt

## calculates congestion window
## call it when NEW ack was received
# def calc_congestion_window_after_new_ack():
    # global CONGESTION_WIN

    # if (CONGESTION_WIN < SSTHRESH):
    #     #slow start
    #     CONGESTION_WIN = CONGESTION_WIN + 1 ##?????????? or cwnd = cwnd + MSS
    # ## congestion avoidance
    # else:
    #     CONGESTION_WIN = CONGESTION_WIN + (1/CONGESTION_WIN) ##?????????? or cwnd = cwnd+ mss*(mss/cwnd)

## if duplicate or old ack:
# if tcp.ack==snd.una:    # duplicate acknowledgement
#     dupacks++
#     if dupacks==3:
#       retransmitsegment(snd.una)
#       ssthresh=max(cwnd/2,2*MSS)
#       cwnd=ssthresh
#   else:    # ack for old segment, ignored
#     dupacks=0

# def send_next_packet(data):
#     global SEQUENCE
#     global lastByteSent

#     if (len(data) > 0):
#               ## binary encode
#           msg = json.dumps({"sequence": SEQUENCE, "data": data, "ack": False, "eof": False}) #, "digested": digest_data(data)})
#           SEQUENCE += len(data)
#           log("[sequence n] " + str(SEQUENCE))

#           if sock.sendto(msg, dest) < len(msg):
#           log("[error] unable to fully send packet")
#           else:
#               lastByteSent += len(data)
#               log("[last byte sent] " + str(lastByteSent))
#           log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
#           return True
#     else:
#           return False

def decode(data):

    unpack_format = "!LB" # time is a double    
    unpacked = struct.unpack(unpack_format, data)
    sequence_number, ack = unpacked    
    data_segment = { "sequence_number": sequence_number, "ack": ack }
    log("[data segment]=" + json.dumps(data_segment))
    return data_segment

s = Sender()

def read_input():
    log("hi")
    global all_data
    all_data = sys.stdin.read()
    log("[all data] length=" + len(all_data))
    s.send()

read_input()

# Now read in data, send packets
while True:
    log("ABOUT TO SLEEP")
    result = sock.recvfrom(MSS)

    if result:
        (data, addr) = result
        try:
            decoded = decode(data)

            ## We process only ACKs and ignore anything else
            # If there is an ack, send next packet
            if decoded['ack']: # == SEQUENCE:
                s.process_ack(decoded)
       
                # Try to send next packet; break if no more data
                # if (not send_next_packet()):
                #     break
                s.send()
        except (ValueError, KeyError, TypeError):
            log("[recv corrupt packet]")
    else:
        log("[error] timeout")
        sys.exit(-1)

#sock.sendto(json.dumps({"src": 1, "dest": 2, "eof": True, "data": "", "sequence": SEQUENCE, "ack": False}), dest)
sys.exit(0)
