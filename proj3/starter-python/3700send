#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#
# NEW RENO: http://research.ijcaonline.org/volume40/number12/pxc3877351.pdf
# SACK: http://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/

import sys
import socket
import time
import datetime
import select
import json
import hashlib
import struct
from threading import Timer, Thread, Lock

## Maximum segment size, in bytes. Same for both sending/receiving endpoints.
MSS = 522
DATA_LENGTH = 500

TIMEOUT = 30

# EFFECTIVE_WINDOW = min(CONGESTION_WIN, ADV_WIN)
# STATE = 0 #0 = slow start, 1 = AI
ALPHA = 0.875

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)
# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
sock.settimeout(TIMEOUT)

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


class Sender(object):

    def __init__(self):
        #Current congestion window size, in bytes.
        self.data = ""
        self.cong_window = MSS
        '''Last advertised size of the currently available space in the receiver's buffer.'''
        self.recv_window = 65536
        self.last_byte_sent = 0
        self.last_byte_acked = 0
        self.last_byte_sent_before_3dup_acks = -1
        self.sent_data = {} # entry = {<seq>: {sent: Boolean, timeout: int, sent_time: double}}
        self.acked_data = {}  # {<seq> : Boolean}
        self.RTT = 1.0 # one second
        '''
        The Slow-Start threshold is a dynamically-set value indicating
        an upper bound on the congestion window above which a
        TCP sender transitions from Slow-Start to the Congestion Avoidance
        state. The default value is 65535 bytes (or 64 KBytes).
        '''
        self.ssthresh = 65535

        self.dup_ack_thresh = 3
        '''
        Counter of duplicate acknowledgments.
        If the counter reaches three (3) or more dup-ACKs, the sender assumes
        that the oldest unacknowledged segment is lost and needs to be retransmitted. */
        '''
        self.dup_ack_count = 0

    def send(self):
        if (len(s.data) > 0):
            ## 1. How many segments are currently unacknowledged
            flight_size = self.last_byte_sent - self.last_byte_acked
            ## 2. How many segments can still be sent - usable window
            effective_window = self.cong_window - flight_size ### or min(self.cong_window, self.recv_window)
            if (effective_window < 0):
                effective_window = 0
            log("[congestion window]=" + str(self.cong_window) + " [recv_window]=" + str(self.recv_window) + "[effective window]=" + str(effective_window) + "[flight size]=" + str(flight_size))
            burst_size = effective_window / MSS ##, ##remaining data - len(data[lastByteSent:])? / MSS);
            log("[burst size]=" + str(burst_size))
            if (burst_size > 0): 
                ## Send the "burstSize" worth of segments:
                i = 0
                while (i < burst_size) :
                    ##Extract one segment of data
                    packet = self.create_packet() 
                    #log("[created this packet]=" + str(packet))

                    if sock.sendto(packet, dest) < len(packet):
                        log("[error] unable to fully send packet")
                    else:
                        log("[send data] " + str(self.last_byte_sent) + " (" + str(len(packet)) + ")")
                        timeout = self.calc_timeout()
                        self.sent_data[self.last_byte_sent] = {"sent": True, "timeout": timeout, "sent_time": time.time()}
                        self.acked_data[self.last_byte_sent] = False
                        #Timer(timeout, self.fast_retransmit, [self.last_byte_sent]).start()
                        #self.last_byte_sent += MSS
                        #log("[last byte sent after sending packet]=" + str(self.last_byte_sent))
                    i = i + 1

    def calc_timeout(self, t):
        if (self.last_byte_sent in self.sent_data):
            old_timeout = self.sent_data[self.last_byte_sent]["timeout"]
        else:
            old_timeout = self.RTT
        new_timeout = (1 - ALPHA) * t + ALPHA * self.RTT
        log("[calculated_timeout]=" + str(new_timeout))
        return new_timeout

    def digest_data(self, data):
        s = ""
        for d in data: 
            s += str(d)
        #log("[check digested]=" + str(s) + "for data=" + str(data))
        return hashlib.md5(s).digest()

    def create_packet(self):
        segment = s.data[self.last_byte_sent: self.last_byte_sent + MSS]
        if (((self.last_byte_sent + MSS) / MSS) >= ((len(s.data)) / MSS)):
            log("[SENDING LAST PIECE]")
            eof = True
        else:
            eof = False
        ack = False
        flags = (eof << 1) + ack
        digested = self.digest_data([self.last_byte_sent, flags, segment])
        tcp_header = struct.pack("!LH16s", self.last_byte_sent, flags, digested)
        #log("[last byte sent]=" + str(self.last_byte_sent) + " ack=" + str(ack) + " eof=" + str(eof) + " segment check=" + str(digested) + " header_size=" + str(struct.calcsize("!LH16s")))
        #log("[tcp header]=" + tcp_header)
        data_packet = tcp_header + segment
        return data_packet
   
    def calc_cong_window_after_new_ask(self):
        if (self.cong_window < self.ssthresh):
            self.cong_window += 1
            log("[slow start] congestion window=" + str(self.cong_window))
        else:
            self.cong_window += 1
            #self.cong_window = self.cong_window + self.cong_window / MSS
            log("[congestion avoidance] congestion window=" + str(self.cong_window))
        ## initial slow start:
        #if (self.last_byte_sent_before_3dup_acks == -1):
            ## here check if there is any bytes of data that were not acked
            #if (self.last_byte_acked < self.last_byte_sent):
                ## calculate RTO here?
            #else:
                ## eveyrthing is acked, we are not waiting for any data to be acked!
            #return self.cong_window + (sequence_number - last_acked - 1)
        #else:
            # This is a slow start recovering after a segment loss
            # and before the sender has acknowledged all the segments
            # that were outstanding at the time 3x dupACKs were received,
            # the sender counts cumulative ACKs as worth only a single MSS.
            #return self.cong_window + MSS;

    def process_new_ack(self, packet):
        # Update the Last-Byte-Acked param, but memorize the previous value
        last_byte_acked_previous = self.last_byte_acked;
        self.last_byte_acked = packet["sequence_number"];
        # Update congestion window
        self.calc_cong_window_after_new_ask(packet["sequence_number"], last_byte_acked_previous);
        # ? also reset the counter of duplicate ACKs.
        self.dup_ack_count = 0;
        log("[processed new ack] last_byte_acked=" + str(self.last_byte_acked) + "congestion window=" + str(self.cong_window))

        acked = True
        while acked:
            if ((self.last_byte_sent in self.acked_data) and (self.acked_data[self.last_byte_sent])):
                self.last_byte_sent += MSS
            else:
                acked = False
        ## To figure out next state:
        # if (self.cong_window < self.ssthresh):
            ## this is slow start
        # else:
            ## congestion avoidance

    def fast_retransmit(self, packet):
        log("[fast retransmit] how did we get here????????")
        if (self.last_byte_sent_before_3dup_acks < 0):
            self.last_byte_sent_before_3dup_acks = self.last_byte_sent

        flight_size = self.last_byte_sent - self.last_byte_acked;
        ##??? check this
        self.ssthresh = flight_size / 2;
        self.ssthresh -= (self.ssthresh % MSS);
        self.ssthresh = max(self.ssthresh, 2 * MSS);

        self.cong_window = max(flight_size / 2, 2 * MSS) + 3 * MSS;

        ## ?? how to do this
        oldest_not_acked_segment = '123'
        sock.sendto(oldest_not_acked_segment, dest)


    def process_dup_ack(self, packet):
        self.dup_ack_count = self.dup_ack_count + 1
        if (self.dup_ack_count >= 3):
            self.fast_retransmit(packet)

    def process_ack(self, packet):
        log("[recv ack] " + str(packet["sequence_number"]))
        self.RTT = time.time() - self.sent_data[packet["sequence_number"]]['sent_time']
        self.acked_data[packet["sequence_number"]] = True
        #self.last_byte_acked = packet["sequence_number"]
        log("[got ack with sequence number]=" + str(packet["sequence_number"]))
        log("[my last_byte_acked]=" + str(self.last_byte_acked))
        if (packet["sequence_number"] == self.last_byte_acked):
            ## figure out current state and process new ack accordingly
            self.process_new_ack(packet)
            # If all outstanding data at 3 dupACKs have been acked, reset the indicator parameter.
            if (self.last_byte_sent_before_3dup_acks <= self.last_byte_acked):
                self.last_byte_sent_before_3dup_acks = -1          
        ## If duplicate ack
        else:
            ## figure out current state and process dup ack accordingly
            self.process_dup_ack(packet)

    def transmit_packet(self, seqnum):
        # set all tcp header and data values
        pos = (seqnum - self.first_byte)
        pos_bytes = pos * DATA_LENGTH
        data = self.data[pos_bytes : pos_bytes + DATA_LENGTH]

        #segment = s.data[self.last_byte_sent: self.last_byte_sent + MSS]
        if (((self.last_byte_sent + MSS) / MSS) >= ((len(s.data)) / MSS)):
            log("[SENDING LAST PIECE]")
            eof = True
        else:
            eof = False
        ack = False
        flags = (eof << 1) + ack
        digested = self.digest_data([self.last_byte_sent, flags, data])
        tcp_header = struct.pack("!LH16s", self.last_byte_sent, flags, digested)
        #log("[last byte sent]=" + str(self.last_byte_sent) + " ack=" + str(ack) + " eof=" + str(eof) + " segment check=" + str(digested) + " header_size=" + str(struct.calcsize("!LH16s")))
        #log("[tcp header]=" + tcp_header)
        packet = tcp_header + data

        # send binary data across the wire
        sock.sendto(packet, dest)
        # mark packet as having been transmitted
        p = self.sent_data[seqnum]
        p['sent'] = True
        p['sent_time'] = time.time()
        # calculate and set new timeout
        p['timeout'] = self.calc_timeout(p['timeout'])
        # start timeout timer for retransmitting packet
        #Timer(p['timeout'], self.retransmit_packet, [seqnum]).start()

    def get_window(self):
        lower = self.last_byte_sent
        upper = self.last_byte_sent + self.cong_window
        # make sure upper doesn't exceed the last base sequence number
        if upper > self.last_byte:
            upper =  self.last_byte
        log("[window range]=" + str(range(lower, upper)))
        return range(lower, upper)


    def send_untransmitted(self):
        for p in self.get_window():
            if not self.sent_data[p]['sent']:
                self.transmit_packet(p)

    def ack(self, data):
        self.acked_data[data["sequence_number"]] = True
        self.calc_cong_window_after_new_ask()
        if data["sequence_number"] == self.last_byte_sent:
            #move base until next un-acked packet'''
            while self.acked_data[self.last_byte_sent]:
                # if all packets have been acked, marked transmission as finished
                if self.last_byte_sent == self.last_byte - DATA_LENGTH:
                    self.finished_transmitting = True
                self.last_byte_sent += DATA_LENGTH
            # if transmission isn't finished, retransmit packets
            if not self.finished_transmitting:
                self.send_untransmitted()

    def sendall(self):
        self.finished_transmitting = False
        self.segments_number = len(self.data) / DATA_LENGTH

        if len(self.data) % DATA_LENGTH: 
            self.segments_number += 1

        self.first_byte = self.last_byte_sent
        self.last_byte = self.last_byte_sent + self.segments_number

        self.populate_sent_data()
        self.populate_acked_data()

        self.send_untransmitted()

        # start looking for incoming acks
        while not self.finished_transmitting:
            # receive data struct and unpack into variables
            result = sock.recvfrom(MSS)

            if result:
                (data, addr) = result
                #try:
                decoded = decode(data)
                if decoded['ack']:
                    s.ack(decoded)
                #except (ValueError, KeyError, TypeError):
                 #   log("[recv corrupt packet]")
            else:
                log("[error] timeout")
                sys.exit(-1)

            # src, dst, seqnum, acknum, headlen, checksum, fin, eof, unused, data = \
            #     self.segment.unpack(ack_data)
            # # make sure packet is an ack
            # if acknum >= 0:
            #     # update round trip time
            #     self.rtt = (datetime.now() - self.transmitted[acknum]['time']).total_seconds()
            #     # log received ack
            #     self.logger.log(
            #         'source: {0}, destination: {1}, seqnum: {2}, acknum: {3}, eof: {4}, rtt: {5}'.format(
            #         src, dst, seqnum, acknum, eof, self.rtt)
            #     )
            #     # mark packet as acked
            #     self.ack(acknum)

    def populate_sent_data(self):
        for x in range(self.first_byte, self.last_byte):
            self.sent_data[x] = {"sent": False, "timeout": 1.0}
        log("[populated data]" + json.dumps(self.sent_data))

    def populate_acked_data(self):
        for x in range(self.first_byte, self.last_byte):
            self.acked_data[x] = False
        log("[populated acked]" + json.dumps(self.acked_data))

        

def decode(data):
    unpack_format = "!LB"  
    unpacked = struct.unpack(unpack_format, data)
    sequence_number, ack = unpacked    
    data_segment = { "sequence_number": sequence_number, "ack": ack }
    log("[data segment]=" + json.dumps(data_segment))
    return data_segment

s = Sender()

def read_input():
    s.data = sys.stdin.read()
    log("[all data] length=" + str(len(s.data)))
    s.sendall()

read_input()

# Now read in data, send packets

# while True:
#     log("ABOUT TO SLEEP")
#     result = sock.recvfrom(MSS)

#     if result:
#         (data, addr) = result
#         #try:
#         decoded = decode(data)
#         if decoded['ack']:
#             s.process_ack(decoded)
#             if not self.finished_transmitting:
#                 s.send()
#         #except (ValueError, KeyError, TypeError):
#          #   log("[recv corrupt packet]")
#     else:
#         log("[error] timeout")
#         sys.exit(-1)

#sock.sendto(json.dumps({"src": 1, "dest": 2, "eof": True, "data": "", "sequence": SEQUENCE, "ack": False}), dest)
sys.exit(0)
