#!/usr/bin/env python

import sys, socket, random, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)

datastore = {} 

class Replica(object):
    def __init__(self):
        self.my_id = sys.argv[1] 
        self.state = "f" # follower, candidate, leader
        self.folowers = [] # for leaders only
        self.logs = {} # {index_number: {term: 1, key: 123, val: "asdf", action: get/put}}
        self.commit_index = 0
        self.last_applied = 0
        self.term = 0
        self.leader = "FFFF" 
        self.votes = 0
        self.datastore = {}
        self.voted_for = -1
        self.last_heartbeat = time.time()
        self.election_timeout = random.uniform(0.15, 0.3)
        # for leaders
        self.next_index = [] # for each server, index of the next log entry to send to that server. Init to leader last lof index + 1
        self.match_index = [] # for each server, index of highest log entry known to be replicated on server. init to 0 then i++

    def get_last_log(self):
        last_index = max(self.logs.keys())
        last_log = self.logs[last_index] 
        last_log["log_index"] = last_index       
        return last_log

    def request_vote(self):
        self.term += 1
        self.state = "c"
        self.votes += 1
        last_log = self.get_last_log()
        req_vote = {"src": self.my_id, "dst": "FFFF", "term": self.term, "type": "req_vote", "last_log": last_log}
        sock.send(json.dumps(req_vote) + "\n")

    def candidate_up_to_date(msg):
        my_last_log = self.get_last_log()
        my_last_log_term = last_log["term"]
        if my_last_log_term < msg["last_log"]["term"]: # term of last log entry
            return True
        elif my_last_log_term > msg["last_log"]["term"]:
            return False
        else:
            return my_last_log["log_index"] <= msg["last_log"]["log_index"]

    def elect_canditate(self, request):
        # received a stale req and respond negatively
        if self.term > request["term"]:
            print "request vote denied, stale term %s" % request["src"]
            response = {"src": self.my_id, "dst": request["src"], "term": self.term, "type": "vote_result", "vote": "no"}
            sock.send(json.dumps(response) + "\n")
        # the current replica is outdated then switch to follower
        elif self.term < request["term"]:
            print "I'm outdated, switching to follower"
            self.state = "f"
            self.term = request["term"] 
        if self.voted_for == -1 and self.candidate_up_to_date(request):
            print "send request vote response %s to %s" %(self.my_id, request["src"])
            self.voted_for == request["src"]
            response = {"src": self.my_id, "dst": request["src"], "term": self.term, "type": "vote_result", "vote": "yes"}
            sock.send(json.dumps(response) + "\n")

    def redirect(self, msg):
        print "in redirect"
        redirect_msg = {"src": self.my_id, "dst": msg["src"], "MID": msg["MID"], "leader": self.leader, "type": "redirect"}
        print "====> REDIRECT: %s" % json.dumps(redirect_msg)
        sock.send(json.dumps(redirect_msg) + "\n") 
    

    def handle_log(self, msg):
        if msg['type'] in ['get', 'put']:
            #sock.send(json.dumps({'src': self.my_id, 'dst': msg['src'], 'leader': 'FFFF','type': 'fail', 'MID': msg['MID']}) + '\n')
            print "%s got a log: %s" % (self.my_id, json.dumps(msg))
            if self.state == "f": #im a follower - redirect to leader
                self.redirect(msg)
            elif self.state == "l":
                self.replicate_log(msg)

        elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
    
    def put(self, data):
        return 0
    
    def get(self, key):
        return 0
    
    def send_heartbeat(self):
        msg = {'src': my_id, 'dst': "FFFF", 'leader': self.leader, 'type': 'heartbeat'}
        sock.send(json.dumps(msg) + '\n')
        print '%s sending a heartbeat to %s' % (msg['src'], msg['dst'])
        self.last_heartbeat = clock

    def main(self):
        last_heartbeat_sent = 0
        while True:
            ready = select.select([sock], [], [], 0.1)[0]
            if sock in ready:
                raw = sock.recv(32768)
                
                # we may receive multiple messages during a single recv(); \n denotes the break between messages
                for msg_raw in raw.split('\n'):
                    ##print msg_raw
                    if len(msg_raw) == 0: continue
                    msg = json.loads(msg_raw)
            
                    # For now, respond to all client messages with a type=fail response
                    if msg['type'] in ['get', 'put']:
                        self.handle_log(msg)
                    # Handle noop messages. This may be removed from your final implementation
                    elif msg['type'] == 'noop':
                        print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
            if self.state == "l":
                clock = time.time()
                if clock - last_heartbeat_sent > 0.05: #send heartbeats every 50ms
                    self.send_heartbeat()
                    last_heartbeat_sent = clock

                # Send a no-op message to a random peer every two seconds, just for fun
                # You definitely want to remove this from your implementation
                #msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': self.leader, 'type': 'noop'}
                #sock.send(json.dumps(msg) + '\n')
                #print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
                #last = clock
    
r = Replica()
r.main()
