#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)

datastore = {} 

class Replica(object):
    def __init__(self):
        self.my_id = sys.argv[1] 
        self.state = "f" # follower, candidate, leader
        self.folowers = [] # for leaders only
        self.logs = {} # {index_number: {term: 1, key: 123, val: "asdf", action: get/put}}
        self.term = 0
        self.votes = 0
    
    def request_vote(self):
        self.term += 1
        self.state = "c"
        self.votes += 1
        req_vote = {"src": self.my_id, "dst": "FFFF",  "type": "req_vote", "logs": json.dumps(self.logs.keys())}
        sock.send(json.dumps(req_vote) + "\n")

    def elect_canditate(self, vote_request):
        request = json.loads(vote_request)
        my_last_logid = max(self.logs.keys())
        candidates_last_logid = max(request["logs"])
        if my_last_logid <= candidates_last_logid:
            #vote for that candidate
            return 0
        else:
            #reject
            return 0
    def handle_log(self, msg):
        if self.state = "l": #If im a leader
            print "I'm a leader"
        else:
            print "redirect"
            self.redirect(msg)

    def redirect(self, msg):
        #{'src': self.my_id, 'dst': msg['src'], 'leader': 'FFFF','type': 'fail', 'MID': msg['MID']}) + '\n'
        redirect_msg = {"src": msg["src"], }
    def put(self, data):
        return 0
    
    def get(self, key):
        return 0



    def main(self):
        last = 0
        while True:
            ready = select.select([sock], [], [], 0.1)[0]
            if sock in ready:
                raw = sock.recv(32768)
                
                # we may receive multiple messages during a single recv(); \n denotes the break between messages
                for msg_raw in raw.split('\n'):
                    print msg_raw
                    if len(msg_raw) == 0: continue
                    msg = json.loads(msg_raw)
            
                    # For now, respond to all client messages with a type=fail response
                    if msg['type'] in ['get', 'put']:
                        sock.send(json.dumps({'src': self.my_id, 'dst': msg['src'], 'leader': 'FFFF',
                                                  'type': 'fail', 'MID': msg['MID']}) + '\n')
                        print "MY ID: %s" % self.my_id        
                        self.handle_log(msg)
                    # Handle noop messages. This may be removed from your final implementation
                    elif msg['type'] == 'noop':
                        print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
                    
            clock = time.time()
            if clock-last > 2:
                # Send a no-op message to a random peer every two seconds, just for fun
                # You definitely want to remove this from your implementation
                msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
                sock.send(json.dumps(msg) + '\n')
                print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
                last = clock
    
r = Replica()
r.main()
