#!/usr/bin/env python

import sys, socket, math, random, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]
total_servers = 1 + len(replica_ids)
quorum = math.ceil(total_servers / 2.0)
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)

datastore = {} 

class Replica(object):
    def __init__(self):
        self.my_id = sys.argv[1] 
        self.state = "f" # follower, candidate, leader
        self.neighbors = sys.argv[2:] # for leaders its a list of followers
        self.logs = [] #{} # {index_number: {term: 1, key: 123, val: "asdf", action: get/put}}
        self.last_commit_index = -1
        self.last_commit_term = -1
        self.last_applied = 0
        self.term = 0
        self.leader = "FFFF" 
        self.datastore = {}
        self.voted_for = -1
        self.election_timeout = random.uniform(0.15, 0.3)
        self.last_response_received = 0 # only from leaders or candidates
        #for candidate
        self.voters = []
        # for leaders
        self.committed_followers = []
        self.next_index = {} # for each server, index of the next log entry to send to that server. Init to leader last lof index + 1
        self.match_index = {} # for each server, index of highest log entry known to be replicated on server. init to 0 then i++
        self.commit_result = {}

    def get_last_log(self):
        last_log = {}
        last_log["log_term"] = -1
        last_log["log_index"] = -1
        #if there are no logs then return {log_index: -1, term: -1}
        if len(self.logs) > 0:
            last_index = len(self.logs) - 1 #max(self.logs.keys())
            last_log = self.logs[last_index].copy()#self.logs[last_index].copy() 
            last_log["log_index"] = last_index       
        return last_log

    #================for candidates ================
    def request_vote(self):
        self.term += 1
        self.state = "c"
        self.voters.append(self.my_id)
        last_log = self.get_last_log()
        for replica_id in self.neighbors:
            req_vote = {"src": self.my_id, "dst": replica_id, "leader": self.leader, "term": self.term, "type": "req_vote", "last_log": last_log}
            sock.send(json.dumps(req_vote) + "\n")

    def candidate_up_to_date(self, msg):
        my_last_log = self.get_last_log()
        my_last_log_term = my_last_log["log_term"]
        if my_last_log_term < msg["last_log"]["log_term"]: # term of last log entry
            return True
        elif my_last_log_term > msg["last_log"]["log_term"]:
            return False
        else:
            return my_last_log["log_index"] <= msg["last_log"]["log_index"]
    def switch_to_follower(self, request):
        self.state = "f"
        self.leader = request["leader"]
        self.term = max(self.term, request["term"])
        self.voted_for = -1
        self.voters = []
        self.match_index = {}
        self.next_index = {}
        self.committed_followers = []

    def switch_to_leader(self, request):
        if self.state == "c":
            self.state = "l"
            self.leader = self.my_id
            print "%s is a new leader. voters: %s" % (self.my_id, json.dumps(self.voters))
            self.voters = []
            self.voted_for = -1
            self.init_match_index()
            self.init_next_index()
        else:
            print "%s failed to update to become a lreader" % self.my_id
    
    #============= for followers ==============
    def redirect(self, msg):
        print "in redirect"
        redirect_msg = {"src": self.my_id, "dst": msg["src"], "MID": msg["MID"], "leader": self.leader, "type": "redirect"}
        print "====> REDIRECT: %s" % json.dumps(redirect_msg)
        sock.send(json.dumps(redirect_msg) + "\n") 
    
    def elect_candidate(self, request):
        # received a stale req and respond negatively
        if self.term > request["term"]:
            print "request vote denied, %s should update its term" % request["src"]
            response = {"src": self.my_id, "dst": request["src"], "leader": self.leader, "term": self.term, "type": "vote_result", "vote": "no"}
            sock.send(json.dumps(response) + "\n")
        # the current replica is outdated then switch to follower
        elif self.term < request["term"]:
            self.last_response_received = time.time()
            if self.state != "f":
                print "I'm outdated, switching to follower"
                self.switch_to_follower(request)

            if self.voted_for == -1 and self.candidate_up_to_date(request):
                self.voted_for = request["src"]
                self.term = max(self.term, request["term"])
                response = {"src": self.my_id, "dst": request["src"], "leader": self.leader, "term": self.term, "type": "vote_result", "vote": "yes"}
                print "[%s vote response]: %s" %(self.my_id, json.dumps(response))
                sock.send(json.dumps(response) + "\n")
    

    # =========== for leader ================
    def init_next_index(self):
        leader_next_index = len(self.logs)
        print "leader's next index: %d" %leader_next_index
        for replica_id in self.neighbors:
            self.next_index[replica_id] = leader_next_index
    
    def init_match_index(self):
        for replica_id in self.neighbors:
            self.match_index[replica_id] = 0

    def send_heartbeat(self):
        for replica_id in self.neighbors:
            msg = {'src': my_id, 'dst': replica_id,"prev_log_index": self.last_commit_index, "term": self.term, 'leader': self.leader, 'type': 'heartbeat'}
            sock.send(json.dumps(msg) + '\n')
            print '%s sending a heartbeat to %s' % (msg['src'], msg['dst'])
    
    def process_log(self, msg):
        last_log = self.get_last_log()
        log_term = self.term
        log = {"src": msg["src"], "index": len(self.logs),"committed": False, "MID": msg["MID"], "log_term": self.term, "type": msg["type"], "key": msg["key"]}
        if msg["type"] == "put":
            log["value"] = msg["value"]
        self.logs.append(log) #self.logs[log_index] = log
        #print "[logs]: %s" %json.dumps(self.logs)
        print "[logs]: %d" %len(self.logs)#%json.dumps(self.logs)
        self.replicate_log(log.copy())

    def replicate_log(self, log):
        for replica_id in self.neighbors:
            append_entry = {}
            entries = self.logs[self.next_index[replica_id]:]
            append_entry["term"] = self.term
            append_entry["entries"] = entries
            append_entry["type"] = "append_entry"
            append_entry["prev_log_index"] = self.last_commit_index
            append_entry["prev_log_term"] = self.last_commit_term
            append_entry["src"] = self.my_id
            append_entry["dst"] = replica_id
            append_entry["leader"] = self.leader
            sock.send(json.dumps(append_entry) + "\n")
            #sock.send(json.dumps({'src': self.my_id, 'dst': msg['src'], 'leader': self.leader,'type': 'fail', 'MID': msg['MID']}) + '\n')

    #============== handling messages ===================
    def handle_log(self, msg):
        if msg['type'] in ['get', 'put']:
            print "%s got a log: src: %s, MID %s" % (self.my_id, msg["src"], msg["MID"])
            if self.state == "f": #im a follower - redirect to leader
                self.redirect(msg)
            elif self.state == "l":
                self.process_log(msg)
    def reply_to_ae(self, next_index, status, result):
        msg = {}
        if status == "fail":
            msg={"src": self.my_id, "dst": self.leader, "term": self.term, "type": "fail", "leader": self.leader, "next_index": next_index, "result": result}
        elif status == "success":
            msg = {"src": self.my_id, "dst": self.leader, "term": self.term, "type": "success", "leader": self.leader, "next_index": next_index, "result": result}
        sock.send(json.dumps(msg) + "\n")


    def commit(self, log_index):
        log = self.logs[log_index]
        #{"committed": false, "src": "001C", "MID": "8", "value": "2b", "key": "EA", "log_term": 1, "type": "put"}
        if log["type"] == "put":
            self.datastore[log["key"]] = log["value"]
            log["committed"] = True 
            return {"client_id": log["src"], "MID": log["MID"], "type": "put", "log_index": log_index}
        elif log["type"] == "get":
            value = self.datastore[log["key"]]
            print "[value]: %s" %value
            log["committed"] = True
            return {"client_id": log["src"], "MID": log["MID"],"type": "get", "value": value, "log_index": log_index}
        else:
            print "wrong action: %s" %log["type"]

    def add_entries(self, entries):
        for entry in entries:
            if entry not in self.logs:
                self.logs.append(entry)
                print "%s added a log src:%s, MID: %s" %(self.my_id, entry["src"], entry["MID"])
            else:
                print "[%s]: src %s MID %s is already in logs" %(self.my_id, entry["src"], entry["MID"])#, json.dumps(self.logs)); 

    def handle_append_entry(self, msg):
        print "[AE %s]: %s" %(self.my_id, json.dumps(msg))
        # src, dst, leader, prev_log_index, type, entries, term
        if self.term > msg["term"]:
            print "[reject]: stale term in append entry"
        elif self.term <= msg["term"]:
            self.last_response_received = time.time()
            if msg["prev_log_index"] == -1:# and len(self.logs) == 0: #no logs before that
                print "[%s]:no logs needed to be committed" %self.my_id
                self.add_entries(msg["entries"])
                self.reply_to_ae(len(self.logs), "success", {}) #next one expecting
            elif len(self.logs) - 1 < msg["prev_log_index"]: #if my last log is smaller than leader's
                print "[reject]: follower has less logs than leader"
                self.reply_to_ae(len(self.logs), "fail", {}) #next index expecting 
            elif self.logs[msg["prev_log_index"]]["log_term"] != msg["prev_log_term"]:
                print "[reject]: unmatched terms"
                # delete the existing entry and all that follow it
                new_logs = self.logs[:msg["prev_log_index"]]
                self.logs = new_logs
                self.reply_to_ae(len(self.logs), "fail", {})
            else:
                result = self.commit(msg["prev_log_index"]) #{clientid, MID, log_index, type, value if get}
                self.add_entries(msg["entries"])
                self.reply_to_ae(len(self.logs), "success", result)
                print "alles gut"
    

    def handle_vote_result(self, result):
        if self.state != "c":
            print "%s is not a candidate but received a vote response " % self.my_id
        else:
            print "%s received a vote result %s" %(self.my_id, json.dumps(result))
            if self.term > result["term"]:
                print "stale term in voteresult"
            elif self.term < result["term"]:
                print "Im behind, switching to follower"
            else:
                if result["vote"] == "yes":
                    self.voters.append(result["src"])
                    print "total votes: %s, quorum: %s" %(str(len(self.voters)), str(quorum))
                    if len(self.voters) >= quorum: #reched the quorum
                        self.switch_to_leader(result)
                else:
                    print "got denied: %s" %json.dumps(result)
   
    def handle_heartbeat(self, msg):
        if self.term > msg["term"]:
            print "%s doesnt recognise leader: %s" %(self.my_id, json.dumps(msg))
        elif self.term <= msg["term"]:
            self.last_response_received = time.time()
            if self.state == "c" or self.state == "l":
                self.switch_to_follower(msg)
            else: #I'm a follower
                if self.leader != msg["leader"]: #new leader is elected
                    self.leader = msg["leader"]
                if msg["prev_log_index"] != -1: #something shoud be committed
                    if not self.logs[msg["prev_log_index"]]["committed"]: 
                        print "[something should be committed]"
                        result = self.commit(msg["prev_log_index"])
                        self.reply_to_ae(len(self.logs), "success", result)
                print "[heartbeat]: %s: leader - %s, term - %s, log - " %(self.my_id, self.leader, self.term)#, json.dumps(self.logs))
                self.voted_for = -1
                self.term = max(self.term, msg["term"])
    def put(self, data):
        return 0
    
    def get(self, key):
        return 0
    
    def handle_ae_result(self, msg):
        #"src": self.my_id, "dst": self.leader, "term": self.term, "type": "success", "leader", "next_index", "result":
        if self.state != "l":
            print "[error]: %s is not a leader but got a ae response" % self.my_id
        elif self.term < msg["term"]:
            print "converting to follower from leader"
            self.switch_to_follower(msg)
        else:
            if msg["type"] == "success" and msg["result"] == self.commit_result:
                self.committed_followers.append(msg["src"])
                self.next_index[msg["src"]] = msg["next_index"]
                #check forquorum
                print "matching results: %s" %json.dumps(self.commit_result)
                if len(self.committed_followers) >= quorum:
                    #if reached quorum, 
                    #if it is, then reply to leader
                    self.reply_to_client("ok", msg["result"])
                    #commit log[commit+1]: next commit
                    self.commit_result = self.commit(self.last_commit_index + 1)
                    #last_commit_index = commit++
                    self.last_commit_index = self.last_commit_index + 1
                    self.last_commit_term = self.logs[self.last_commit_index]["log_term"]
                    self.committed_followers = []
            elif msg["type"] == "fail":
                self.next_index[msg["src"]] = msg["next_index"]
                print "fail"
            else:
                print "[!!!!!]: %s vs %s" %(json.dumps(msg["result"]), json.dumps(self.commit_result))
    
    def reply_to_client(self, status, result):
        print "[result]: %s, %s" %(json.dumps(result), json.dumps(self.committed_followers))
        if result:
            if result["log_index"] == self.last_commit_index:
                response = {"src": self.my_id, "leader": self.leader, "dst": result["client_id"], "MID": result["MID"], "type": status}
                if result["type"] == "get" and status == "ok":
                    print "=======> GET"
                    response["value"] = result["value"]
                sock.send(json.dumps(response) + "\n")
                print "[replied to client]"
            else:
                print "commit index is not matching"
        else:
            print "epmty result"

    def main(self):
        self.last_response_received = time.time()
        last_heartbeat_sent = time.time()
        print "%s is starting. Election timeout: %s ms" %(self.my_id, str(self.election_timeout))
        while True:
            current = time.time()
            if (current - self.last_response_received) > self.election_timeout and self.state == "f": #timeout
                self.request_vote()

            ready = select.select([sock], [], [], 0.1)[0]
            if sock in ready:
                raw = sock.recv(32768)
                #print "[new msg] %s" %(raw)
                # we may receive multiple messages during a single recv(); \n denotes the break between messages
                for msg_raw in raw.split('\n'):
                    if len(msg_raw) == 0: continue
                    try:
                        msg = json.loads(msg_raw)
                             
                        # For now, respond to all client messages with a type=fail response
                        if msg['type'] in ['get', 'put']:
                            self.handle_log(msg)
                        elif msg["type"] in ["fail", "success"]:
                            print "[%s]: %s" %(msg["type"], json.dumps(msg))
                            self.handle_ae_result(msg)
                        elif msg["type"] == "heartbeat":
                            #print "%s received a heartbeat from %s" % (self.my_id, msg["src"])
                            self.handle_heartbeat(msg)
                        elif msg["type"] == "append_entry":
                            self.handle_append_entry(msg)
                        elif msg["type"] == "redirect":
                            print "received a redirect"
                            self.handle_redirect(msg)
                        elif msg["type"] == "vote_result":
                            self.handle_vote_result(msg)
                        elif msg["type"] == "req_vote":
                            print "%s received a vote request %s " %(self.my_id, json.dumps(msg))
                            self.elect_candidate(msg)
                        # Handle noop messages. This may be removed from your final implementation
                        elif msg['type'] == 'noop':
                            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
                    except ValueError:
                        print "[INCOMPLETE MSG]"

            if self.state == "l":
                clock = time.time()
                if clock - last_heartbeat_sent > 0.05: #send heartbeats every 50ms
                    self.send_heartbeat()
                    last_heartbeat_sent = clock

r = Replica()
r.main()
